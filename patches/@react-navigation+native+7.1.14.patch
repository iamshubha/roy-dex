diff --git a/node_modules/@react-navigation/native/lib/module/createMemoryHistory.js b/node_modules/@react-navigation/native/lib/module/createMemoryHistory.js
index 474db5e..4b47a93 100644
--- a/node_modules/@react-navigation/native/lib/module/createMemoryHistory.js
+++ b/node_modules/@react-navigation/native/lib/module/createMemoryHistory.js
@@ -1,6 +1,38 @@
 "use strict";
 
 import { nanoid } from 'nanoid/non-secure';
+
+const isExtension = typeof window !== 'undefined' && process.env.ONEKEY_PLATFORM === 'ext'
+
+function fixHashInExtension(path) {
+  if (isExtension) {
+    if (
+      !path.includes('.html') &&
+      path !== '/' &&
+      path !== '' &&
+      path !== undefined &&
+      path !== null
+    ) {
+      const currentIndexHtml = globalThis.location.href.split('.html')?.[0];
+      const currentIndexHtmlWithoutSlash = currentIndexHtml.split('/')?.pop();
+      if (currentIndexHtmlWithoutSlash) {
+        const currentPath = path.includes('#') ? path.split('#').pop() : path;
+        return `/${currentIndexHtmlWithoutSlash}.html#${currentPath}`;
+      }
+    }
+
+    let lastHash = path.includes('#') ? path.split('#').pop() : '';
+    lastHash = lastHash === '/' ? '' : lastHash;
+
+    const indexHtmlFile = path.split('.html')?.[0];
+    if (indexHtmlFile) {
+      return lastHash ? `${indexHtmlFile}.html#${lastHash}` : `${indexHtmlFile}.html`;
+    }
+    return path;
+  }
+  return path;
+}
+
 export function createMemoryHistory() {
   let index = 0;
   let items = [];
@@ -64,9 +96,10 @@ export function createMemoryHistory() {
       // We don't store state object in history.state because:
       // - browsers have limits on how big it can be, and we don't control the size
       // - while not recommended, there could be non-serializable data in state
+      const pathWithHash = fixHashInExtension(path);
       window.history.pushState({
         id
-      }, '', path);
+      }, '', pathWithHash);
     },
     replace({
       path,
@@ -104,9 +137,10 @@ export function createMemoryHistory() {
           id
         };
       }
+      const newPathWithHash = fixHashInExtension(pathWithHash);
       window.history.replaceState({
         id
-      }, '', pathWithHash);
+      }, '', newPathWithHash);
     },
     // `history.go(n)` is asynchronous, there are couple of things to keep in mind:
     // - it won't do anything if we can't go `n` steps, the `popstate` event won't fire.
diff --git a/node_modules/@react-navigation/native/src/createMemoryHistory.tsx b/node_modules/@react-navigation/native/src/createMemoryHistory.tsx
index 1568263..2adaaec 100644
--- a/node_modules/@react-navigation/native/src/createMemoryHistory.tsx
+++ b/node_modules/@react-navigation/native/src/createMemoryHistory.tsx
@@ -10,6 +10,37 @@ type HistoryRecord = {
   path: string;
 };
 
+const isExtension = typeof window !== 'undefined' && process.env.ONEKEY_PLATFORM === 'ext'
+
+function fixHashInExtension(path: string) {
+  if (isExtension) {
+    if (
+      !path.includes('.html') &&
+      path !== '/' &&
+      path !== '' &&
+      path !== undefined &&
+      path !== null
+    ) {
+      const currentIndexHtml = globalThis.location.href.split('.html')?.[0];
+      const currentIndexHtmlWithoutSlash = currentIndexHtml.split('/')?.pop();
+      if (currentIndexHtmlWithoutSlash) {
+        const currentPath = path.includes('#') ? path.split('#').pop() : path;
+        return `/${currentIndexHtmlWithoutSlash}.html#${currentPath}`;
+      }
+    }
+
+    let lastHash = path.includes('#') ? path.split('#').pop() : '';
+    lastHash = lastHash === '/' ? '' : lastHash;
+
+    const indexHtmlFile = path.split('.html')?.[0];
+    if (indexHtmlFile) {
+      return lastHash ? `${indexHtmlFile}.html#${lastHash}` : `${indexHtmlFile}.html`;
+    }
+    return path;
+  }
+  return path;
+}
+
 export function createMemoryHistory() {
   let index = 0;
   let items: HistoryRecord[] = [];
@@ -76,7 +107,8 @@ export function createMemoryHistory() {
       // We don't store state object in history.state because:
       // - browsers have limits on how big it can be, and we don't control the size
       // - while not recommended, there could be non-serializable data in state
-      window.history.pushState({ id }, '', path);
+      const pathWithHash = fixHashInExtension(path);
+      window.history.pushState({ id }, '', pathWithHash);
     },
 
     replace({ path, state }: { path: string; state: NavigationState }) {
@@ -96,7 +128,6 @@ export function createMemoryHistory() {
         //   the page when navigating forward in history.
         // - This is the first time any state modifications are done
         //   So we need to push the entry as there's nothing to replace
-
         pathWithHash = pathWithHash + hash;
         items = [{ path: pathWithHash, state, id }];
         index = 0;
@@ -107,7 +138,8 @@ export function createMemoryHistory() {
         items[index] = { path, state, id };
       }
 
-      window.history.replaceState({ id }, '', pathWithHash);
+      const newPathWithHash = fixHashInExtension(pathWithHash);
+      window.history.replaceState({ id }, '', newPathWithHash);
     },
 
     // `history.go(n)` is asynchronous, there are couple of things to keep in mind:
